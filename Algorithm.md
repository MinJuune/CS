## 1. 시간 복잡도와 공간 복잡도에 대해 설명해 보세요. 

**시간 복잡도**는 알고리즘이 실행되는데 걸리는 연산 횟수를, 입력 크기 n의 함수로 나타낸 것이고,    
**공간 복잡도**는 알고리즘이 실행되는 동안 필요한 메모리 사용량을, 입력 크기 n의 함수로 나타낸 것입니다.  

<br><br>

## 2-1. 정렬 알고리즘(버블/ 선택/ 삽입 정렬)에 대해 설명해 보세요. 

**버블 정렬**은 인접한 두 원소를 비교해 큰 값을 뒤로 보내는 정렬 알고리즘입니다.  
시간 복잡도는 O(n^2)로, 구현은 간단하지만 비효율적입니다.  
**선택 정렬**은 매 단계마다 가장 작은 값을 찾아서 앞쪽에 차례대로 배치하는 정렬 알고리즘입니다.  
비교 횟수는 많지만, 교환 횟수는 적습니다.  
시간 복잡도는 O(n^2)로, 구현은 간단하지만 비효율적입니다.  
**삽입 정렬**은 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 배열의 원소를 정렬된 배열의 올바를 위치에 하나씩 삽입하는 정렬 알고리즘입니다.  
평균과 최악의 경우 시간 복잡도는 O(n^2)이지만, 거의 정렬된 최선의 경우 시간 복잡도는 O(n)입니다.  

<br><br>

## 2-2. 정렬 알고리즘(퀵, 병합, 힙, 위상 정렬)에 대해 설명해 보세요.  

**퀵 정렬**은  
기준 원소인 피벗을 하나 정하고, 피벗보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할한 뒤, 각 부분 배열을 재귀적으로 정렬하는 알고리즘입니다.  
평균적으로 시간 복잡도는 O(nlogn)이지만, 최악의 경우(피벗을 잘못 선택한 경우) O(n^2)입니다.  
빠르지만 피벗 선택이 성능에 큰 영향을 준다는 특징이 있습니다.  
**병합 정렬**  
리스트를 절반으로 나눈 뒤, 각각을 (재귀적으로) 정렬하고, 두 개의 정렬된 부분 리스트를 합하여, 전체가 정렬된 리스트가 되게 하는 방법입니다.  
시간 복잡도는 항상 O(nlogn)입니다.    
**힙 정렬**은 완전 이진 트리인 힙을 사용하는 정렬 알고리즘입니다.  
최대 힙을 만들어 루트 값을 맨 뒤로 보내고, 나머지 부분에 대해 힙을 다시 구성하며 반복하는 알고리즘입니다.  
시간 복잡도는 항상 O(nlogn)입니다.  
**위상 정렬**은 사이클이 없는 방향 그래프(DAG)에서, 노드의 선행 관계를 고려하여, 순서를 결정하는 알고리즘입니다.     
시간 복잡도는 O(E+V)이고, 일반적인 정렬과 달리, 그래프 구조의 순서 결정 문제에 사용됩니다.  

<br><br>

## 2-3. 정렬 얄고리즘(Counting Sort/Radix Sort)에 대해 설명해 보세요. 

**Counting Sort**는 각 값의 등장 횟수를 세서 누적합으로 정렬하는 정렬 알고리즘입니다. 
시간 복잡도는 O(N+K)으로, 범위가 좁은 데이터에 적합합니다.  
**Radix Sort**는 각 자릿수를 기준으로 Counting Sort를 반복하여 정렬하는 정렬 알고리즘입니다.  
시간 복잡도는 O(dx(NxK))이고, 고정 자릿수 데이터에 적합합니다.  

<br><br>

# 3. 이진 탐색(Binary Search)에 대해 설명해 보세요.  

<strong>이진 탐색(Binary Search)</strong>은 정렬된 배열에서, 중간 값을 기준으로 탐색 범위를 줄이는 탐색 알고리즘으로, 시간 복잡도는 O(logn)입니다. 

<br><br>

# 4. 분할 정복 알고리즘과 DP와의 차이에 대해 설명해 보세요.  

**분할 정복**은 큰 문제를 작은 문제로 나누고(Devide), 각 부분 문제를 독립적으로 해결한 뒤(Conquer), 그 결과를 합쳐(Merge) 전체 문제의 해를 구하는 알고리즘입니다.  
대표 알고리즘으로 퀵 정렬, 병합 정렬, 이진 탐색 등이 있습니다.  
분할 정복과 DP는 둘다 문제를 쪼개서 해결한다는 공통점이 있지만,  
**분할 정복**은 하위 문제가 독립적이고,  
**DP**는 하위 문제가 겹치기 때문에, 결과를 저장해 재활용 가능하다는 차이점이 있습니다.  

<br><br>

# 5. 그리디 알고리즘에 대해 설명해 보세요.  
 
**그리디 알고리즘**은 매 순간 가장 좋아보이는 선택을 하는 알고리즘입니다.  
대표적인 예시로 다익스트라 알고리즘이 그리디 알고리즘을 사용합니다.  

<br><br>

# 6. DP(Dynamic Programming)에 대해 설명해 보세요.  

**DP**는 큰 문제를 여러개의 작은 문제로 나누고, 하위 문제의 결과를 저장해 재활용함으로써, 중복 계산을 줄이는 알고리즘입니다.  

<br><br>

# 7. 그래프에 대해 설명해 보세요.  

**그래프**는 정점(Vertex)과 간선(Edge)으로 이루어진 비선형 자료구조로, 객체간의 관계나 연결을 표현할 때 사용됩니다.  

<br><br>

# 8. 그래프 탐색에 대해 설명해 보세요.  

**그래프 탐색**은 그래프의 모든 정점을 한 번씩 방문하는 방법입니다.  
대표적으로 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)이 있습니다.  
**DFS**는 한 경로를 끝까지 탐색한 뒤, 다른 경로를 탐색하는 알고리즘으로, 모든 가능한 경로를 찾을 때 사용합니다.  
**BFS**는 시작 노드에서 가장 가까운 노드부터 차례대로 탐색하는 알고리즘으로, 최단 거리를 탐색하고자 할 때 사용합니다.  

<br><br>

# 9. 최단 경로 알고리즘에 대해 설명해 보세요.  

**최단 경로 알고리즘**은 그래프에서 두 정점 사이의 최소 비용 경로를 찾는 알고리즘입니다.  
대표적으로 다익스트라, 벨만-포드, 플로이드 와샬 3가지 방법이 있습니다.  
**다익스트라**는 가중치가 양수인 그래프에서, 한 정점으로부터 최단 거리를 구하는 알고리즘으로 greedy 접근 기반입니다.  
**벨만-포드**는 한 정점에서 다른 모든 정점까지의 최단 거리를 구하는 알고리즘으로, 다익스트라와 달리 가중치가 음수인 그래프에서도 처리 가능하다는 특징이 있고, DP 기반입니다.  
**플로이드 와샬**은 모든 정점 쌍간 최단 거리를 구하는 알고리즘으로 DP 기반입니다.  

<br><br>

# 10. 최소 신장 트리(Minimum Spanning Tree, MST)와 이를 해결하는 대표적인 알고리즘을 설명해 보세요.  

**최소 신장 트리**는 모든 노드를 연결하면서, 총 가중치가 최소인 트리입니다.  
이를 구하는 대표적인 알고리즘은 Kruskal 알고리즘과 Prim 알고리즘이 있습니다.  
**Kruskal 알고리즘**은 간선(Edge)을 오름차순으로 정렬하고, cycle이 생기지 않도록 하나씩 선택하는 방법이고,  
**Prim 알고리즘**은 하나의 노드에서 시작해, 연결된 간선 중, 가장 가중치가 작은 간선을 추가해 확장해 나가는 방법입니다.  

<br><br>